{"ast":null,"code":"import _slicedToArray from \"/Users/eyliu/Desktop/FitBuddy/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/Users/eyliu/Desktop/FitBuddy/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/eyliu/Desktop/FitBuddy/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"defaultTransition\"],\n  _excluded2 = [\"delay\", \"times\", \"type\"];\nimport { createGeneratorEasing } from '../../easing/utils/create-generator-easing.mjs';\nimport { resolveElements } from '../../render/dom/utils/resolve-element.mjs';\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\nimport { fillOffset } from '../../utils/offsets/fill.mjs';\nimport { progress } from '../../utils/progress.mjs';\nimport { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\nimport { calcNextTime } from './utils/calc-time.mjs';\nimport { addKeyframes } from './utils/edit.mjs';\nimport { compareByTime } from './utils/sort.mjs';\nvar defaultSegmentEasing = \"easeInOut\";\nfunction createAnimationsFromSequence(sequence) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$defaultTransitio = _ref.defaultTransition,\n    defaultTransition = _ref$defaultTransitio === void 0 ? {} : _ref$defaultTransitio,\n    sequenceTransition = _objectWithoutProperties(_ref, _excluded);\n  var scope = arguments.length > 2 ? arguments[2] : undefined;\n  var defaultDuration = defaultTransition.duration || 0.3;\n  var animationDefinitions = new Map();\n  var sequences = new Map();\n  var elementCache = {};\n  var timeLabels = new Map();\n  var prevTime = 0;\n  var currentTime = 0;\n  var totalDuration = 0;\n  /**\n   * Build the timeline by mapping over the sequence array and converting\n   * the definitions into keyframes and offsets with absolute time values.\n   * These will later get converted into relative offsets in a second pass.\n   */\n  var _loop = function _loop() {\n      var segment = sequence[i];\n      /**\n       * If this is a timeline label, mark it and skip the rest of this iteration.\n       */\n      if (typeof segment === \"string\") {\n        timeLabels.set(segment, currentTime);\n        return 0; // continue\n      } else if (!Array.isArray(segment)) {\n        timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n        return 0; // continue\n      }\n      var _segment = _slicedToArray(segment, 3),\n        subject = _segment[0],\n        keyframes = _segment[1],\n        _segment$ = _segment[2],\n        transition = _segment$ === void 0 ? {} : _segment$;\n      /**\n       * If a relative or absolute time value has been specified we need to resolve\n       * it in relation to the currentTime.\n       */\n      if (transition.at !== undefined) {\n        currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n      }\n      /**\n       * Keep track of the maximum duration in this definition. This will be\n       * applied to currentTime once the definition has been parsed.\n       */\n      var maxDuration = 0;\n      var resolveValueSequence = function resolveValueSequence(valueKeyframes, valueTransition, valueSequence) {\n        var elementIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        var numElements = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n        var valueKeyframesAsList = keyframesAsList(valueKeyframes);\n        var _valueTransition$dela = valueTransition.delay,\n          delay = _valueTransition$dela === void 0 ? 0 : _valueTransition$dela,\n          _valueTransition$time = valueTransition.times,\n          times = _valueTransition$time === void 0 ? defaultOffset(valueKeyframesAsList) : _valueTransition$time,\n          _valueTransition$type = valueTransition.type,\n          type = _valueTransition$type === void 0 ? \"keyframes\" : _valueTransition$type,\n          remainingTransition = _objectWithoutProperties(valueTransition, _excluded2);\n        var _valueTransition$ease = valueTransition.ease,\n          ease = _valueTransition$ease === void 0 ? defaultTransition.ease || \"easeOut\" : _valueTransition$ease,\n          duration = valueTransition.duration;\n        /**\n         * Resolve stagger() if defined.\n         */\n        var calculatedDelay = typeof delay === \"function\" ? delay(elementIndex, numElements) : delay;\n        /**\n         * If this animation should and can use a spring, generate a spring easing function.\n         */\n        var numKeyframes = valueKeyframesAsList.length;\n        if (numKeyframes <= 2 && type === \"spring\") {\n          /**\n           * As we're creating an easing function from a spring,\n           * ideally we want to generate it using the real distance\n           * between the two keyframes. However this isn't always\n           * possible - in these situations we use 0-100.\n           */\n          var absoluteDelta = 100;\n          if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {\n            var delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n            absoluteDelta = Math.abs(delta);\n          }\n          var springTransition = _objectSpread({}, remainingTransition);\n          if (duration !== undefined) {\n            springTransition.duration = secondsToMilliseconds(duration);\n          }\n          var springEasing = createGeneratorEasing(springTransition, absoluteDelta);\n          ease = springEasing.ease;\n          duration = springEasing.duration;\n        }\n        duration !== null && duration !== void 0 ? duration : duration = defaultDuration;\n        var startTime = currentTime + calculatedDelay;\n        var targetTime = startTime + duration;\n        /**\n         * If there's only one time offset of 0, fill in a second with length 1\n         */\n        if (times.length === 1 && times[0] === 0) {\n          times[1] = 1;\n        }\n        /**\n         * Fill out if offset if fewer offsets than keyframes\n         */\n        var remainder = times.length - valueKeyframesAsList.length;\n        remainder > 0 && fillOffset(times, remainder);\n        /**\n         * If only one value has been set, ie [1], push a null to the start of\n         * the keyframe array. This will let us mark a keyframe at this point\n         * that will later be hydrated with the previous value.\n         */\n        valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null);\n        /**\n         * Add keyframes, mapping offsets to absolute time.\n         */\n        addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n        maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n        totalDuration = Math.max(targetTime, totalDuration);\n      };\n      if (isMotionValue(subject)) {\n        var subjectSequence = getSubjectSequence(subject, sequences);\n        resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n      } else {\n        /**\n         * Find all the elements specified in the definition and parse value\n         * keyframes from their timeline definitions.\n         */\n        var elements = resolveElements(subject, scope, elementCache);\n        var numElements = elements.length;\n        /**\n         * For every element in this segment, process the defined values.\n         */\n        for (var elementIndex = 0; elementIndex < numElements; elementIndex++) {\n          /**\n           * Cast necessary, but we know these are of this type\n           */\n          keyframes = keyframes;\n          transition = transition;\n          var element = elements[elementIndex];\n          var _subjectSequence = getSubjectSequence(element, sequences);\n          for (var key in keyframes) {\n            resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, _subjectSequence), elementIndex, numElements);\n          }\n        }\n        prevTime = currentTime;\n        currentTime += maxDuration;\n      }\n    },\n    _ret;\n  for (var i = 0; i < sequence.length; i++) {\n    _ret = _loop();\n    if (_ret === 0) continue;\n  }\n  /**\n   * For every element and value combination create a new animation.\n   */\n  sequences.forEach(function (valueSequences, element) {\n    for (var key in valueSequences) {\n      var valueSequence = valueSequences[key];\n      /**\n       * Arrange all the keyframes in ascending time order.\n       */\n      valueSequence.sort(compareByTime);\n      var keyframes = [];\n      var valueOffset = [];\n      var valueEasing = [];\n      /**\n       * For each keyframe, translate absolute times into\n       * relative offsets based on the total duration of the timeline.\n       */\n      for (var _i = 0; _i < valueSequence.length; _i++) {\n        var _valueSequence$_i = valueSequence[_i],\n          at = _valueSequence$_i.at,\n          value = _valueSequence$_i.value,\n          easing = _valueSequence$_i.easing;\n        keyframes.push(value);\n        valueOffset.push(progress(0, totalDuration, at));\n        valueEasing.push(easing || \"easeOut\");\n      }\n      /**\n       * If the first keyframe doesn't land on offset: 0\n       * provide one by duplicating the initial keyframe. This ensures\n       * it snaps to the first keyframe when the animation starts.\n       */\n      if (valueOffset[0] !== 0) {\n        valueOffset.unshift(0);\n        keyframes.unshift(keyframes[0]);\n        valueEasing.unshift(defaultSegmentEasing);\n      }\n      /**\n       * If the last keyframe doesn't land on offset: 1\n       * provide one with a null wildcard value. This will ensure it\n       * stays static until the end of the animation.\n       */\n      if (valueOffset[valueOffset.length - 1] !== 1) {\n        valueOffset.push(1);\n        keyframes.push(null);\n      }\n      if (!animationDefinitions.has(element)) {\n        animationDefinitions.set(element, {\n          keyframes: {},\n          transition: {}\n        });\n      }\n      var definition = animationDefinitions.get(element);\n      definition.keyframes[key] = keyframes;\n      definition.transition[key] = _objectSpread(_objectSpread({}, defaultTransition), {}, {\n        duration: totalDuration,\n        ease: valueEasing,\n        times: valueOffset\n      }, sequenceTransition);\n    }\n  });\n  return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n  !sequences.has(subject) && sequences.set(subject, {});\n  return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n  if (!sequences[name]) sequences[name] = [];\n  return sequences[name];\n}\nfunction keyframesAsList(keyframes) {\n  return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\nfunction getValueTransition(transition, key) {\n  return transition[key] ? _objectSpread(_objectSpread({}, transition), transition[key]) : _objectSpread({}, transition);\n}\nvar isNumber = function isNumber(keyframe) {\n  return typeof keyframe === \"number\";\n};\nvar isNumberKeyframesArray = function isNumberKeyframesArray(keyframes) {\n  return keyframes.every(isNumber);\n};\nexport { createAnimationsFromSequence, getValueTransition };","map":{"version":3,"names":["createGeneratorEasing","resolveElements","defaultOffset","fillOffset","progress","secondsToMilliseconds","isMotionValue","calcNextTime","addKeyframes","compareByTime","defaultSegmentEasing","createAnimationsFromSequence","sequence","_ref","arguments","length","undefined","_ref$defaultTransitio","defaultTransition","sequenceTransition","_objectWithoutProperties","_excluded","scope","defaultDuration","duration","animationDefinitions","Map","sequences","elementCache","timeLabels","prevTime","currentTime","totalDuration","_loop","segment","i","set","Array","isArray","name","at","_segment","_slicedToArray","subject","keyframes","_segment$","transition","maxDuration","resolveValueSequence","valueKeyframes","valueTransition","valueSequence","elementIndex","numElements","valueKeyframesAsList","keyframesAsList","_valueTransition$dela","delay","_valueTransition$time","times","_valueTransition$type","type","remainingTransition","_excluded2","_valueTransition$ease","ease","calculatedDelay","numKeyframes","absoluteDelta","isNumberKeyframesArray","delta","Math","abs","springTransition","_objectSpread","springEasing","startTime","targetTime","remainder","unshift","max","subjectSequence","getSubjectSequence","getValueSequence","elements","element","key","getValueTransition","_ret","forEach","valueSequences","sort","valueOffset","valueEasing","_valueSequence$_i","value","easing","push","has","definition","get","isNumber","keyframe","every"],"sources":["/Users/eyliu/Desktop/FitBuddy/node_modules/framer-motion/dist/es/animation/sequence/create.mjs"],"sourcesContent":["import { createGeneratorEasing } from '../../easing/utils/create-generator-easing.mjs';\nimport { resolveElements } from '../../render/dom/utils/resolve-element.mjs';\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\nimport { fillOffset } from '../../utils/offsets/fill.mjs';\nimport { progress } from '../../utils/progress.mjs';\nimport { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\nimport { calcNextTime } from './utils/calc-time.mjs';\nimport { addKeyframes } from './utils/edit.mjs';\nimport { compareByTime } from './utils/sort.mjs';\n\nconst defaultSegmentEasing = \"easeInOut\";\nfunction createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope) {\n    const defaultDuration = defaultTransition.duration || 0.3;\n    const animationDefinitions = new Map();\n    const sequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < sequence.length; i++) {\n        const segment = sequence[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (typeof segment === \"string\") {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        let [subject, keyframes, transition = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (transition.at !== undefined) {\n            currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numElements = 0) => {\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n            const { delay = 0, times = defaultOffset(valueKeyframesAsList), type = \"keyframes\", ...remainingTransition } = valueTransition;\n            let { ease = defaultTransition.ease || \"easeOut\", duration } = valueTransition;\n            /**\n             * Resolve stagger() if defined.\n             */\n            const calculatedDelay = typeof delay === \"function\"\n                ? delay(elementIndex, numElements)\n                : delay;\n            /**\n             * If this animation should and can use a spring, generate a spring easing function.\n             */\n            const numKeyframes = valueKeyframesAsList.length;\n            if (numKeyframes <= 2 && type === \"spring\") {\n                /**\n                 * As we're creating an easing function from a spring,\n                 * ideally we want to generate it using the real distance\n                 * between the two keyframes. However this isn't always\n                 * possible - in these situations we use 0-100.\n                 */\n                let absoluteDelta = 100;\n                if (numKeyframes === 2 &&\n                    isNumberKeyframesArray(valueKeyframesAsList)) {\n                    const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n                    absoluteDelta = Math.abs(delta);\n                }\n                const springTransition = { ...remainingTransition };\n                if (duration !== undefined) {\n                    springTransition.duration = secondsToMilliseconds(duration);\n                }\n                const springEasing = createGeneratorEasing(springTransition, absoluteDelta);\n                ease = springEasing.ease;\n                duration = springEasing.duration;\n            }\n            duration !== null && duration !== void 0 ? duration : (duration = defaultDuration);\n            const startTime = currentTime + calculatedDelay;\n            const targetTime = startTime + duration;\n            /**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */\n            if (times.length === 1 && times[0] === 0) {\n                times[1] = 1;\n            }\n            /**\n             * Fill out if offset if fewer offsets than keyframes\n             */\n            const remainder = times.length - valueKeyframesAsList.length;\n            remainder > 0 && fillOffset(times, remainder);\n            /**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */\n            valueKeyframesAsList.length === 1 &&\n                valueKeyframesAsList.unshift(null);\n            /**\n             * Add keyframes, mapping offsets to absolute time.\n             */\n            addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n            maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n            totalDuration = Math.max(targetTime, totalDuration);\n        };\n        if (isMotionValue(subject)) {\n            const subjectSequence = getSubjectSequence(subject, sequences);\n            resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n        }\n        else {\n            /**\n             * Find all the elements specified in the definition and parse value\n             * keyframes from their timeline definitions.\n             */\n            const elements = resolveElements(subject, scope, elementCache);\n            const numElements = elements.length;\n            /**\n             * For every element in this segment, process the defined values.\n             */\n            for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n                /**\n                 * Cast necessary, but we know these are of this type\n                 */\n                keyframes = keyframes;\n                transition = transition;\n                const element = elements[elementIndex];\n                const subjectSequence = getSubjectSequence(element, sequences);\n                for (const key in keyframes) {\n                    resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), elementIndex, numElements);\n                }\n            }\n            prevTime = currentTime;\n            currentTime += maxDuration;\n        }\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    sequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(progress(0, totalDuration, at));\n                valueEasing.push(easing || \"easeOut\");\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(defaultSegmentEasing);\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            if (!animationDefinitions.has(element)) {\n                animationDefinitions.set(element, {\n                    keyframes: {},\n                    transition: {},\n                });\n            }\n            const definition = animationDefinitions.get(element);\n            definition.keyframes[key] = keyframes;\n            definition.transition[key] = {\n                ...defaultTransition,\n                duration: totalDuration,\n                ease: valueEasing,\n                times: valueOffset,\n                ...sequenceTransition,\n            };\n        }\n    });\n    return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n    !sequences.has(subject) && sequences.set(subject, {});\n    return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\nfunction keyframesAsList(keyframes) {\n    return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\nfunction getValueTransition(transition, key) {\n    return transition[key]\n        ? { ...transition, ...transition[key] }\n        : { ...transition };\n}\nconst isNumber = (keyframe) => typeof keyframe === \"number\";\nconst isNumberKeyframesArray = (keyframes) => keyframes.every(isNumber);\n\nexport { createAnimationsFromSequence, getValueTransition };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}