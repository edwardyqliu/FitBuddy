{"ast":null,"code":"import _objectSpread from \"/Users/eyliu/Desktop/FitBuddy/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"/Users/eyliu/Desktop/FitBuddy/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\nimport { animateTarget } from './visual-element-target.mjs';\nfunction animateVariant(visualElement, variant) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var resolved = resolveVariant(visualElement, variant, options.custom);\n  var _ref = resolved || {},\n    _ref$transition = _ref.transition,\n    transition = _ref$transition === void 0 ? visualElement.getDefaultTransition() || {} : _ref$transition;\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  /**\n   * If we have a variant, create a callback that runs it as an animation.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n  var getAnimation = resolved ? function () {\n    return Promise.all(animateTarget(visualElement, resolved, options));\n  } : function () {\n    return Promise.resolve();\n  };\n  /**\n   * If we have children, create a callback that runs all their animations.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n  var getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? function () {\n    var forwardDelay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var _transition = transition,\n      _transition$delayChil = _transition.delayChildren,\n      delayChildren = _transition$delayChil === void 0 ? 0 : _transition$delayChil,\n      staggerChildren = _transition.staggerChildren,\n      staggerDirection = _transition.staggerDirection;\n    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n  } : function () {\n    return Promise.resolve();\n  };\n  /**\n   * If the transition explicitly defines a \"when\" option, we need to resolve either\n   * this animation or all children animations before playing the other.\n   */\n  var _transition2 = transition,\n    when = _transition2.when;\n  if (when) {\n    var _ref2 = when === \"beforeChildren\" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation],\n      _ref3 = _slicedToArray(_ref2, 2),\n      first = _ref3[0],\n      last = _ref3[1];\n    return first().then(function () {\n      return last();\n    });\n  } else {\n    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n  }\n}\nfunction animateChildren(visualElement, variant) {\n  var delayChildren = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var staggerChildren = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var staggerDirection = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  var options = arguments.length > 5 ? arguments[5] : undefined;\n  var animations = [];\n  var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n  var generateStaggerDuration = staggerDirection === 1 ? function () {\n    var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return i * staggerChildren;\n  } : function () {\n    var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return maxStaggerDuration - i * staggerChildren;\n  };\n  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach(function (child, i) {\n    child.notify(\"AnimationStart\", variant);\n    animations.push(animateVariant(child, variant, _objectSpread(_objectSpread({}, options), {}, {\n      delay: delayChildren + generateStaggerDuration(i)\n    })).then(function () {\n      return child.notify(\"AnimationComplete\", variant);\n    }));\n  });\n  return Promise.all(animations);\n}\nfunction sortByTreeOrder(a, b) {\n  return a.sortNodePosition(b);\n}\nexport { animateVariant, sortByTreeOrder };","map":{"version":3,"names":["resolveVariant","animateTarget","animateVariant","visualElement","variant","options","arguments","length","undefined","resolved","custom","_ref","_ref$transition","transition","getDefaultTransition","transitionOverride","getAnimation","Promise","all","resolve","getChildAnimations","variantChildren","size","forwardDelay","_transition","_transition$delayChil","delayChildren","staggerChildren","staggerDirection","animateChildren","_transition2","when","_ref2","_ref3","_slicedToArray","first","last","then","delay","animations","maxStaggerDuration","generateStaggerDuration","i","Array","from","sort","sortByTreeOrder","forEach","child","notify","push","_objectSpread","a","b","sortNodePosition"],"sources":["/Users/eyliu/Desktop/FitBuddy/node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs"],"sourcesContent":["import { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\nimport { animateTarget } from './visual-element-target.mjs';\n\nfunction animateVariant(visualElement, variant, options = {}) {\n    const resolved = resolveVariant(visualElement, variant, options.custom);\n    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getAnimation = resolved\n        ? () => Promise.all(animateTarget(visualElement, resolved, options))\n        : () => Promise.resolve();\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size\n        ? (forwardDelay = 0) => {\n            const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n        }\n        : () => Promise.resolve();\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    const { when } = transition;\n    if (when) {\n        const [first, last] = when === \"beforeChildren\"\n            ? [getAnimation, getChildAnimations]\n            : [getChildAnimations, getAnimation];\n        return first().then(() => last());\n    }\n    else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n    }\n}\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n    const animations = [];\n    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n    const generateStaggerDuration = staggerDirection === 1\n        ? (i = 0) => i * staggerChildren\n        : (i = 0) => maxStaggerDuration - i * staggerChildren;\n    Array.from(visualElement.variantChildren)\n        .sort(sortByTreeOrder)\n        .forEach((child, i) => {\n        child.notify(\"AnimationStart\", variant);\n        animations.push(animateVariant(child, variant, {\n            ...options,\n            delay: delayChildren + generateStaggerDuration(i),\n        }).then(() => child.notify(\"AnimationComplete\", variant)));\n    });\n    return Promise.all(animations);\n}\nfunction sortByTreeOrder(a, b) {\n    return a.sortNodePosition(b);\n}\n\nexport { animateVariant, sortByTreeOrder };\n"],"mappings":";;AAAA,SAASA,cAAc,QAAQ,iDAAiD;AAChF,SAASC,aAAa,QAAQ,6BAA6B;AAE3D,SAASC,cAAcA,CAACC,aAAa,EAAEC,OAAO,EAAgB;EAAA,IAAdC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EACxD,IAAMG,QAAQ,GAAGT,cAAc,CAACG,aAAa,EAAEC,OAAO,EAAEC,OAAO,CAACK,MAAM,CAAC;EACvE,IAAAC,IAAA,GAAkEF,QAAQ,IAAI,CAAC,CAAC;IAAAG,eAAA,GAAAD,IAAA,CAA1EE,UAAU;IAAVA,UAAU,GAAAD,eAAA,cAAGT,aAAa,CAACW,oBAAoB,CAAC,CAAC,IAAI,CAAC,CAAC,GAAAF,eAAA;EAC7D,IAAIP,OAAO,CAACU,kBAAkB,EAAE;IAC5BF,UAAU,GAAGR,OAAO,CAACU,kBAAkB;EAC3C;EACA;AACJ;AACA;AACA;EACI,IAAMC,YAAY,GAAGP,QAAQ,GACvB;IAAA,OAAMQ,OAAO,CAACC,GAAG,CAACjB,aAAa,CAACE,aAAa,EAAEM,QAAQ,EAAEJ,OAAO,CAAC,CAAC;EAAA,IAClE;IAAA,OAAMY,OAAO,CAACE,OAAO,CAAC,CAAC;EAAA;EAC7B;AACJ;AACA;AACA;EACI,IAAMC,kBAAkB,GAAGjB,aAAa,CAACkB,eAAe,IAAIlB,aAAa,CAACkB,eAAe,CAACC,IAAI,GACxF,YAAsB;IAAA,IAArBC,YAAY,GAAAjB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;IACf,IAAAkB,WAAA,GAAkEX,UAAU;MAAAY,qBAAA,GAAAD,WAAA,CAApEE,aAAa;MAAbA,aAAa,GAAAD,qBAAA,cAAG,CAAC,GAAAA,qBAAA;MAAEE,eAAe,GAAAH,WAAA,CAAfG,eAAe;MAAEC,gBAAgB,GAAAJ,WAAA,CAAhBI,gBAAgB;IAC5D,OAAOC,eAAe,CAAC1B,aAAa,EAAEC,OAAO,EAAEsB,aAAa,GAAGH,YAAY,EAAEI,eAAe,EAAEC,gBAAgB,EAAEvB,OAAO,CAAC;EAC5H,CAAC,GACC;IAAA,OAAMY,OAAO,CAACE,OAAO,CAAC,CAAC;EAAA;EAC7B;AACJ;AACA;AACA;EACI,IAAAW,YAAA,GAAiBjB,UAAU;IAAnBkB,IAAI,GAAAD,YAAA,CAAJC,IAAI;EACZ,IAAIA,IAAI,EAAE;IACN,IAAAC,KAAA,GAAsBD,IAAI,KAAK,gBAAgB,GACzC,CAACf,YAAY,EAAEI,kBAAkB,CAAC,GAClC,CAACA,kBAAkB,EAAEJ,YAAY,CAAC;MAAAiB,KAAA,GAAAC,cAAA,CAAAF,KAAA;MAFjCG,KAAK,GAAAF,KAAA;MAAEG,IAAI,GAAAH,KAAA;IAGlB,OAAOE,KAAK,CAAC,CAAC,CAACE,IAAI,CAAC;MAAA,OAAMD,IAAI,CAAC,CAAC;IAAA,EAAC;EACrC,CAAC,MACI;IACD,OAAOnB,OAAO,CAACC,GAAG,CAAC,CAACF,YAAY,CAAC,CAAC,EAAEI,kBAAkB,CAACf,OAAO,CAACiC,KAAK,CAAC,CAAC,CAAC;EAC3E;AACJ;AACA,SAAST,eAAeA,CAAC1B,aAAa,EAAEC,OAAO,EAAyE;EAAA,IAAvEsB,aAAa,GAAApB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAAA,IAAEqB,eAAe,GAAArB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAAA,IAAEsB,gBAAgB,GAAAtB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAAA,IAAED,OAAO,GAAAC,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAClH,IAAM+B,UAAU,GAAG,EAAE;EACrB,IAAMC,kBAAkB,GAAG,CAACrC,aAAa,CAACkB,eAAe,CAACC,IAAI,GAAG,CAAC,IAAIK,eAAe;EACrF,IAAMc,uBAAuB,GAAGb,gBAAgB,KAAK,CAAC,GAChD;IAAA,IAACc,CAAC,GAAApC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;IAAA,OAAKoC,CAAC,GAAGf,eAAe;EAAA,IAC9B;IAAA,IAACe,CAAC,GAAApC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;IAAA,OAAKkC,kBAAkB,GAAGE,CAAC,GAAGf,eAAe;EAAA;EACzDgB,KAAK,CAACC,IAAI,CAACzC,aAAa,CAACkB,eAAe,CAAC,CACpCwB,IAAI,CAACC,eAAe,CAAC,CACrBC,OAAO,CAAC,UAACC,KAAK,EAAEN,CAAC,EAAK;IACvBM,KAAK,CAACC,MAAM,CAAC,gBAAgB,EAAE7C,OAAO,CAAC;IACvCmC,UAAU,CAACW,IAAI,CAAChD,cAAc,CAAC8C,KAAK,EAAE5C,OAAO,EAAA+C,aAAA,CAAAA,aAAA,KACtC9C,OAAO;MACViC,KAAK,EAAEZ,aAAa,GAAGe,uBAAuB,CAACC,CAAC;IAAC,EACpD,CAAC,CAACL,IAAI,CAAC;MAAA,OAAMW,KAAK,CAACC,MAAM,CAAC,mBAAmB,EAAE7C,OAAO,CAAC;IAAA,EAAC,CAAC;EAC9D,CAAC,CAAC;EACF,OAAOa,OAAO,CAACC,GAAG,CAACqB,UAAU,CAAC;AAClC;AACA,SAASO,eAAeA,CAACM,CAAC,EAAEC,CAAC,EAAE;EAC3B,OAAOD,CAAC,CAACE,gBAAgB,CAACD,CAAC,CAAC;AAChC;AAEA,SAASnD,cAAc,EAAE4C,eAAe"},"metadata":{},"sourceType":"module","externalDependencies":[]}