{"ast":null,"code":"import _toConsumableArray from \"/Users/eyliu/Desktop/FitBuddy/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { invariant } from './errors.mjs';\nimport { color } from '../value/types/color/index.mjs';\nimport { clamp } from './clamp.mjs';\nimport { mix } from './mix.mjs';\nimport { mixColor } from './mix-color.mjs';\nimport { mixComplex, mixArray, mixObject } from './mix-complex.mjs';\nimport { pipe } from './pipe.mjs';\nimport { progress } from './progress.mjs';\nimport { noop } from './noop.mjs';\nvar mixNumber = function mixNumber(from, to) {\n  return function (p) {\n    return mix(from, to, p);\n  };\n};\nfunction detectMixerFactory(v) {\n  if (typeof v === \"number\") {\n    return mixNumber;\n  } else if (typeof v === \"string\") {\n    return color.test(v) ? mixColor : mixComplex;\n  } else if (Array.isArray(v)) {\n    return mixArray;\n  } else if (typeof v === \"object\") {\n    return mixObject;\n  }\n  return mixNumber;\n}\nfunction createMixers(output, ease, customMixer) {\n  var mixers = [];\n  var mixerFactory = customMixer || detectMixerFactory(output[0]);\n  var numMixers = output.length - 1;\n  for (var i = 0; i < numMixers; i++) {\n    var mixer = mixerFactory(output[i], output[i + 1]);\n    if (ease) {\n      var easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\n      mixer = pipe(easingFunction, mixer);\n    }\n    mixers.push(mixer);\n  }\n  return mixers;\n}\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revist this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\nfunction interpolate(input, output) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref$clamp = _ref.clamp,\n    isClamp = _ref$clamp === void 0 ? true : _ref$clamp,\n    ease = _ref.ease,\n    mixer = _ref.mixer;\n  var inputLength = input.length;\n  invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n  /**\n   * If we're only provided a single input, we can just make a function\n   * that returns the output.\n   */\n  if (inputLength === 1) return function () {\n    return output[0];\n  };\n  // If input runs highest -> lowest, reverse both arrays\n  if (input[0] > input[inputLength - 1]) {\n    input = _toConsumableArray(input).reverse();\n    output = _toConsumableArray(output).reverse();\n  }\n  var mixers = createMixers(output, ease, mixer);\n  var numMixers = mixers.length;\n  var interpolator = function interpolator(v) {\n    var i = 0;\n    if (numMixers > 1) {\n      for (; i < input.length - 2; i++) {\n        if (v < input[i + 1]) break;\n      }\n    }\n    var progressInRange = progress(input[i], input[i + 1], v);\n    return mixers[i](progressInRange);\n  };\n  return isClamp ? function (v) {\n    return interpolator(clamp(input[0], input[inputLength - 1], v));\n  } : interpolator;\n}\nexport { interpolate };","map":{"version":3,"names":["invariant","color","clamp","mix","mixColor","mixComplex","mixArray","mixObject","pipe","progress","noop","mixNumber","from","to","p","detectMixerFactory","v","test","Array","isArray","createMixers","output","ease","customMixer","mixers","mixerFactory","numMixers","length","i","mixer","easingFunction","push","interpolate","input","_ref","arguments","undefined","_ref$clamp","isClamp","inputLength","_toConsumableArray","reverse","interpolator","progressInRange"],"sources":["/Users/eyliu/Desktop/FitBuddy/node_modules/framer-motion/dist/es/utils/interpolate.mjs"],"sourcesContent":["import { invariant } from './errors.mjs';\nimport { color } from '../value/types/color/index.mjs';\nimport { clamp } from './clamp.mjs';\nimport { mix } from './mix.mjs';\nimport { mixColor } from './mix-color.mjs';\nimport { mixComplex, mixArray, mixObject } from './mix-complex.mjs';\nimport { pipe } from './pipe.mjs';\nimport { progress } from './progress.mjs';\nimport { noop } from './noop.mjs';\n\nconst mixNumber = (from, to) => (p) => mix(from, to, p);\nfunction detectMixerFactory(v) {\n    if (typeof v === \"number\") {\n        return mixNumber;\n    }\n    else if (typeof v === \"string\") {\n        return color.test(v) ? mixColor : mixComplex;\n    }\n    else if (Array.isArray(v)) {\n        return mixArray;\n    }\n    else if (typeof v === \"object\") {\n        return mixObject;\n    }\n    return mixNumber;\n}\nfunction createMixers(output, ease, customMixer) {\n    const mixers = [];\n    const mixerFactory = customMixer || detectMixerFactory(output[0]);\n    const numMixers = output.length - 1;\n    for (let i = 0; i < numMixers; i++) {\n        let mixer = mixerFactory(output[i], output[i + 1]);\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\n            mixer = pipe(easingFunction, mixer);\n        }\n        mixers.push(mixer);\n    }\n    return mixers;\n}\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revist this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n    const inputLength = input.length;\n    invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n    /**\n     * If we're only provided a single input, we can just make a function\n     * that returns the output.\n     */\n    if (inputLength === 1)\n        return () => output[0];\n    // If input runs highest -> lowest, reverse both arrays\n    if (input[0] > input[inputLength - 1]) {\n        input = [...input].reverse();\n        output = [...output].reverse();\n    }\n    const mixers = createMixers(output, ease, mixer);\n    const numMixers = mixers.length;\n    const interpolator = (v) => {\n        let i = 0;\n        if (numMixers > 1) {\n            for (; i < input.length - 2; i++) {\n                if (v < input[i + 1])\n                    break;\n            }\n        }\n        const progressInRange = progress(input[i], input[i + 1], v);\n        return mixers[i](progressInRange);\n    };\n    return isClamp\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\n        : interpolator;\n}\n\nexport { interpolate };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}