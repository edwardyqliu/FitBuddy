{"ast":null,"code":"import _toConsumableArray from \"/Users/eyliu/Desktop/FitBuddy/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { calcInset } from './inset.mjs';\nimport { ScrollOffset } from './presets.mjs';\nimport { resolveOffset } from './offset.mjs';\nimport { interpolate } from '../../../../utils/interpolate.mjs';\nimport { defaultOffset } from '../../../../utils/offsets/default.mjs';\nvar point = {\n  x: 0,\n  y: 0\n};\nfunction getTargetSize(target) {\n  return \"getBBox\" in target && target.tagName !== \"svg\" ? target.getBBox() : {\n    width: target.clientWidth,\n    height: target.clientHeight\n  };\n}\nfunction resolveOffsets(container, info, options) {\n  var _options$offset = options.offset,\n    offsetDefinition = _options$offset === void 0 ? ScrollOffset.All : _options$offset;\n  var _options$target = options.target,\n    target = _options$target === void 0 ? container : _options$target,\n    _options$axis = options.axis,\n    axis = _options$axis === void 0 ? \"y\" : _options$axis;\n  var lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n  var inset = target !== container ? calcInset(target, container) : point;\n  /**\n   * Measure the target and container. If they're the same thing then we\n   * use the container's scrollWidth/Height as the target, from there\n   * all other calculations can remain the same.\n   */\n  var targetSize = target === container ? {\n    width: container.scrollWidth,\n    height: container.scrollHeight\n  } : getTargetSize(target);\n  var containerSize = {\n    width: container.clientWidth,\n    height: container.clientHeight\n  };\n  /**\n   * Reset the length of the resolved offset array rather than creating a new one.\n   * TODO: More reusable data structures for targetSize/containerSize would also be good.\n   */\n  info[axis].offset.length = 0;\n  /**\n   * Populate the offset array by resolving the user's offset definition into\n   * a list of pixel scroll offets.\n   */\n  var hasChanged = !info[axis].interpolate;\n  var numOffsets = offsetDefinition.length;\n  for (var i = 0; i < numOffsets; i++) {\n    var offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n    if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n      hasChanged = true;\n    }\n    info[axis].offset[i] = offset;\n  }\n  /**\n   * If the pixel scroll offsets have changed, create a new interpolator function\n   * to map scroll value into a progress.\n   */\n  if (hasChanged) {\n    info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition));\n    info[axis].interpolatorOffsets = _toConsumableArray(info[axis].offset);\n  }\n  info[axis].progress = info[axis].interpolate(info[axis].current);\n}\nexport { resolveOffsets };","map":{"version":3,"names":["calcInset","ScrollOffset","resolveOffset","interpolate","defaultOffset","point","x","y","getTargetSize","target","tagName","getBBox","width","clientWidth","height","clientHeight","resolveOffsets","container","info","options","_options$offset","offset","offsetDefinition","All","_options$target","_options$axis","axis","lengthLabel","inset","targetSize","scrollWidth","scrollHeight","containerSize","length","hasChanged","numOffsets","i","interpolatorOffsets","_toConsumableArray","progress","current"],"sources":["/Users/eyliu/Desktop/FitBuddy/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/index.mjs"],"sourcesContent":["import { calcInset } from './inset.mjs';\nimport { ScrollOffset } from './presets.mjs';\nimport { resolveOffset } from './offset.mjs';\nimport { interpolate } from '../../../../utils/interpolate.mjs';\nimport { defaultOffset } from '../../../../utils/offsets/default.mjs';\n\nconst point = { x: 0, y: 0 };\nfunction getTargetSize(target) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? target.getBBox()\n        : { width: target.clientWidth, height: target.clientHeight };\n}\nfunction resolveOffsets(container, info, options) {\n    let { offset: offsetDefinition = ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : getTargetSize(target);\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition));\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = info[axis].interpolate(info[axis].current);\n}\n\nexport { resolveOffsets };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}