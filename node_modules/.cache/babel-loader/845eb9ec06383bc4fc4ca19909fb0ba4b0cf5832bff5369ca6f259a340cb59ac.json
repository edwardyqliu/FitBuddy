{"ast":null,"code":"function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nimport Metadata from '../metadata.js';\nimport matchesEntirely from './matchesEntirely.js';\nvar NON_FIXED_LINE_PHONE_TYPES = ['MOBILE', 'PREMIUM_RATE', 'TOLL_FREE', 'SHARED_COST', 'VOIP', 'PERSONAL_NUMBER', 'PAGER', 'UAN', 'VOICEMAIL']; // Finds out national phone number type (fixed line, mobile, etc)\n\nexport default function getNumberType(input, options, metadata) {\n  // If assigning the `{}` default value is moved to the arguments above,\n  // code coverage would decrease for some weird reason.\n  options = options || {}; // When `parse()` returned `{}`\n  // meaning that the phone number is not a valid one.\n\n  if (!input.country) {\n    return;\n  }\n  metadata = new Metadata(metadata);\n  metadata.selectNumberingPlan(input.country, input.countryCallingCode);\n  var nationalNumber = options.v2 ? input.nationalNumber : input.phone; // The following is copy-pasted from the original function:\n  // https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835\n  // Is this national number even valid for this country\n\n  if (!matchesEntirely(nationalNumber, metadata.nationalNumberPattern())) {\n    return;\n  } // Is it fixed line number\n\n  if (isNumberTypeEqualTo(nationalNumber, 'FIXED_LINE', metadata)) {\n    // Because duplicate regular expressions are removed\n    // to reduce metadata size, if \"mobile\" pattern is \"\"\n    // then it means it was removed due to being a duplicate of the fixed-line pattern.\n    //\n    if (metadata.type('MOBILE') && metadata.type('MOBILE').pattern() === '') {\n      return 'FIXED_LINE_OR_MOBILE';\n    } // `MOBILE` type pattern isn't included if it matched `FIXED_LINE` one.\n    // For example, for \"US\" country.\n    // Old metadata (< `1.0.18`) had a specific \"types\" data structure\n    // that happened to be `undefined` for `MOBILE` in that case.\n    // Newer metadata (>= `1.0.18`) has another data structure that is\n    // not `undefined` for `MOBILE` in that case (it's just an empty array).\n    // So this `if` is just for backwards compatibility with old metadata.\n\n    if (!metadata.type('MOBILE')) {\n      return 'FIXED_LINE_OR_MOBILE';\n    } // Check if the number happens to qualify as both fixed line and mobile.\n    // (no such country in the minimal metadata set)\n\n    /* istanbul ignore if */\n\n    if (isNumberTypeEqualTo(nationalNumber, 'MOBILE', metadata)) {\n      return 'FIXED_LINE_OR_MOBILE';\n    }\n    return 'FIXED_LINE';\n  }\n  for (var _iterator = _createForOfIteratorHelperLoose(NON_FIXED_LINE_PHONE_TYPES), _step; !(_step = _iterator()).done;) {\n    var type = _step.value;\n    if (isNumberTypeEqualTo(nationalNumber, type, metadata)) {\n      return type;\n    }\n  }\n}\nexport function isNumberTypeEqualTo(nationalNumber, type, metadata) {\n  type = metadata.type(type);\n  if (!type || !type.pattern()) {\n    return false;\n  } // Check if any possible number lengths are present;\n  // if so, we use them to avoid checking\n  // the validation pattern if they don't match.\n  // If they are absent, this means they match\n  // the general description, which we have\n  // already checked before a specific number type.\n\n  if (type.possibleLengths() && type.possibleLengths().indexOf(nationalNumber.length) < 0) {\n    return false;\n  }\n  return matchesEntirely(nationalNumber, type.pattern());\n}","map":{"version":3,"names":["Metadata","matchesEntirely","NON_FIXED_LINE_PHONE_TYPES","getNumberType","input","options","metadata","country","selectNumberingPlan","countryCallingCode","nationalNumber","v2","phone","nationalNumberPattern","isNumberTypeEqualTo","type","pattern","_iterator","_createForOfIteratorHelperLoose","_step","done","value","possibleLengths","indexOf","length"],"sources":["/Users/eyliu/Desktop/FitBuddy/node_modules/libphonenumber-js/source/helpers/getNumberType.js"],"sourcesContent":["import Metadata from '../metadata.js'\r\nimport matchesEntirely from './matchesEntirely.js'\r\n\r\nconst NON_FIXED_LINE_PHONE_TYPES = [\r\n\t'MOBILE',\r\n\t'PREMIUM_RATE',\r\n\t'TOLL_FREE',\r\n\t'SHARED_COST',\r\n\t'VOIP',\r\n\t'PERSONAL_NUMBER',\r\n\t'PAGER',\r\n\t'UAN',\r\n\t'VOICEMAIL'\r\n]\r\n\r\n// Finds out national phone number type (fixed line, mobile, etc)\r\nexport default function getNumberType(input, options, metadata)\r\n{\r\n\t// If assigning the `{}` default value is moved to the arguments above,\r\n\t// code coverage would decrease for some weird reason.\r\n\toptions = options || {}\r\n\r\n\t// When `parse()` returned `{}`\r\n\t// meaning that the phone number is not a valid one.\r\n\tif (!input.country) {\r\n\t\treturn\r\n\t}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\tmetadata.selectNumberingPlan(input.country, input.countryCallingCode)\r\n\r\n\tconst nationalNumber = options.v2 ? input.nationalNumber : input.phone\r\n\r\n\t// The following is copy-pasted from the original function:\r\n\t// https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835\r\n\r\n\t// Is this national number even valid for this country\r\n\tif (!matchesEntirely(nationalNumber, metadata.nationalNumberPattern())) {\r\n\t\treturn\r\n\t}\r\n\r\n\t// Is it fixed line number\r\n\tif (isNumberTypeEqualTo(nationalNumber, 'FIXED_LINE', metadata)) {\r\n\t\t// Because duplicate regular expressions are removed\r\n\t\t// to reduce metadata size, if \"mobile\" pattern is \"\"\r\n\t\t// then it means it was removed due to being a duplicate of the fixed-line pattern.\r\n\t\t//\r\n\t\tif (metadata.type('MOBILE') && metadata.type('MOBILE').pattern() === '') {\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\t// `MOBILE` type pattern isn't included if it matched `FIXED_LINE` one.\r\n\t\t// For example, for \"US\" country.\r\n\t\t// Old metadata (< `1.0.18`) had a specific \"types\" data structure\r\n\t\t// that happened to be `undefined` for `MOBILE` in that case.\r\n\t\t// Newer metadata (>= `1.0.18`) has another data structure that is\r\n\t\t// not `undefined` for `MOBILE` in that case (it's just an empty array).\r\n\t\t// So this `if` is just for backwards compatibility with old metadata.\r\n\t\tif (!metadata.type('MOBILE')) {\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\t// Check if the number happens to qualify as both fixed line and mobile.\r\n\t\t// (no such country in the minimal metadata set)\r\n\t\t/* istanbul ignore if */\r\n\t\tif (isNumberTypeEqualTo(nationalNumber, 'MOBILE', metadata)) {\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\treturn 'FIXED_LINE'\r\n\t}\r\n\r\n\tfor (const type of NON_FIXED_LINE_PHONE_TYPES) {\r\n\t\tif (isNumberTypeEqualTo(nationalNumber, type, metadata)) {\r\n\t\t\treturn type\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function isNumberTypeEqualTo(nationalNumber, type, metadata) {\r\n\ttype = metadata.type(type)\r\n\tif (!type || !type.pattern()) {\r\n\t\treturn false\r\n\t}\r\n\t// Check if any possible number lengths are present;\r\n\t// if so, we use them to avoid checking\r\n\t// the validation pattern if they don't match.\r\n\t// If they are absent, this means they match\r\n\t// the general description, which we have\r\n\t// already checked before a specific number type.\r\n\tif (type.possibleLengths() &&\r\n\t\ttype.possibleLengths().indexOf(nationalNumber.length) < 0) {\r\n\t\treturn false\r\n\t}\r\n\treturn matchesEntirely(nationalNumber, type.pattern())\r\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAOA,QAAP,MAAqB,gBAArB;AACA,OAAOC,eAAP,MAA4B,sBAA5B;AAEA,IAAMC,0BAA0B,GAAG,CAClC,QADkC,EAElC,cAFkC,EAGlC,WAHkC,EAIlC,aAJkC,EAKlC,MALkC,EAMlC,iBANkC,EAOlC,OAPkC,EAQlC,KARkC,EASlC,WATkC,CAAnC,C,CAYA;;AACA,eAAe,SAASC,aAATA,CAAuBC,KAAvB,EAA8BC,OAA9B,EAAuCC,QAAvC,EACf;EACC;EACA;EACAD,OAAO,GAAGA,OAAO,IAAI,EAArB,CAHD,CAKC;EACA;;EACA,IAAI,CAACD,KAAK,CAACG,OAAX,EAAoB;IACnB;EACA;EAEDD,QAAQ,GAAG,IAAIN,QAAJ,CAAaM,QAAb,CAAX;EAEAA,QAAQ,CAACE,mBAAT,CAA6BJ,KAAK,CAACG,OAAnC,EAA4CH,KAAK,CAACK,kBAAlD;EAEA,IAAMC,cAAc,GAAGL,OAAO,CAACM,EAAR,GAAaP,KAAK,CAACM,cAAnB,GAAoCN,KAAK,CAACQ,KAAjE,CAfD,CAiBC;EACA;EAEA;;EACA,IAAI,CAACX,eAAe,CAACS,cAAD,EAAiBJ,QAAQ,CAACO,qBAAT,EAAjB,CAApB,EAAwE;IACvE;EACA,CAvBF,CAyBC;;EACA,IAAIC,mBAAmB,CAACJ,cAAD,EAAiB,YAAjB,EAA+BJ,QAA/B,CAAvB,EAAiE;IAChE;IACA;IACA;IACA;IACA,IAAIA,QAAQ,CAACS,IAAT,CAAc,QAAd,KAA2BT,QAAQ,CAACS,IAAT,CAAc,QAAd,EAAwBC,OAAxB,OAAsC,EAArE,EAAyE;MACxE,OAAO,sBAAP;IACA,CAP+D,CAShE;IACA;IACA;IACA;IACA;IACA;IACA;;IACA,IAAI,CAACV,QAAQ,CAACS,IAAT,CAAc,QAAd,CAAL,EAA8B;MAC7B,OAAO,sBAAP;IACA,CAlB+D,CAoBhE;IACA;;IACA;;IACA,IAAID,mBAAmB,CAACJ,cAAD,EAAiB,QAAjB,EAA2BJ,QAA3B,CAAvB,EAA6D;MAC5D,OAAO,sBAAP;IACA;IAED,OAAO,YAAP;EACA;EAED,SAAAW,SAAA,GAAAC,+BAAA,CAAmBhB,0BAAnB,GAAAiB,KAAA,IAAAA,KAAA,GAAAF,SAAA,IAAAG,IAAA,GAA+C;IAAA,IAApCL,IAAoC,GAAAI,KAAA,CAAAE,KAAA;IAC9C,IAAIP,mBAAmB,CAACJ,cAAD,EAAiBK,IAAjB,EAAuBT,QAAvB,CAAvB,EAAyD;MACxD,OAAOS,IAAP;IACA;EACD;AACD;AAED,OAAO,SAASD,mBAATA,CAA6BJ,cAA7B,EAA6CK,IAA7C,EAAmDT,QAAnD,EAA6D;EACnES,IAAI,GAAGT,QAAQ,CAACS,IAAT,CAAcA,IAAd,CAAP;EACA,IAAI,CAACA,IAAD,IAAS,CAACA,IAAI,CAACC,OAAL,EAAd,EAA8B;IAC7B,OAAO,KAAP;EACA,CAJkE,CAKnE;EACA;EACA;EACA;EACA;EACA;;EACA,IAAID,IAAI,CAACO,eAAL,MACHP,IAAI,CAACO,eAAL,GAAuBC,OAAvB,CAA+Bb,cAAc,CAACc,MAA9C,IAAwD,CADzD,EAC4D;IAC3D,OAAO,KAAP;EACA;EACD,OAAOvB,eAAe,CAACS,cAAD,EAAiBK,IAAI,CAACC,OAAL,EAAjB,CAAtB;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}