{"ast":null,"code":"import _objectSpread from \"/Users/eyliu/Desktop/FitBuddy/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectDestructuringEmpty from \"/Users/eyliu/Desktop/FitBuddy/node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js\";\nimport _slicedToArray from \"/Users/eyliu/Desktop/FitBuddy/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { invariant } from '../../../utils/errors.mjs';\nimport { isNumericalString } from '../../../utils/is-numerical-string.mjs';\nimport { isCSSVariableToken } from './is-css-variable.mjs';\n\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\nvar splitCSSVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n  var match = splitCSSVariableRegex.exec(current);\n  if (!match) return [,];\n  var _match = _slicedToArray(match, 3),\n    token = _match[1],\n    fallback = _match[2];\n  return [token, fallback];\n}\nvar maxDepth = 4;\nfunction getVariableValue(current, element) {\n  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  invariant(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\".concat(current, \"\\\". This may indicate a circular fallback dependency.\"));\n  var _parseCSSVariable = parseCSSVariable(current),\n    _parseCSSVariable2 = _slicedToArray(_parseCSSVariable, 2),\n    token = _parseCSSVariable2[0],\n    fallback = _parseCSSVariable2[1];\n  // No CSS variable detected\n  if (!token) return;\n  // Attempt to read this CSS variable off the element\n  var resolved = window.getComputedStyle(element).getPropertyValue(token);\n  if (resolved) {\n    var trimmed = resolved.trim();\n    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;\n  } else if (isCSSVariableToken(fallback)) {\n    // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n    return getVariableValue(fallback, element, depth + 1);\n  } else {\n    return fallback;\n  }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\nfunction resolveCSSVariables(visualElement, _ref, transitionEnd) {\n  var target = Object.assign({}, (_objectDestructuringEmpty(_ref), _ref));\n  var element = visualElement.current;\n  if (!(element instanceof Element)) return {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n  // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n  // only if they change but I think this reads clearer and this isn't a performance-critical path.\n  if (transitionEnd) {\n    transitionEnd = _objectSpread({}, transitionEnd);\n  }\n  // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n  visualElement.values.forEach(function (value) {\n    var current = value.get();\n    if (!isCSSVariableToken(current)) return;\n    var resolved = getVariableValue(current, element);\n    if (resolved) value.set(resolved);\n  });\n  // Cycle through every target property and resolve CSS variables. Currently\n  // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n  for (var key in target) {\n    var current = target[key];\n    if (!isCSSVariableToken(current)) continue;\n    var resolved = getVariableValue(current, element);\n    if (!resolved) continue;\n    // Clone target if it hasn't already been\n    target[key] = resolved;\n    if (!transitionEnd) transitionEnd = {};\n    // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n    // CSS variable. This will ensure that after the animation the component will reflect\n    // changes in the value of the CSS variable.\n    if (transitionEnd[key] === undefined) {\n      transitionEnd[key] = current;\n    }\n  }\n  return {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\nexport { parseCSSVariable, resolveCSSVariables };","map":{"version":3,"names":["invariant","isNumericalString","isCSSVariableToken","splitCSSVariableRegex","parseCSSVariable","current","match","exec","_match","_slicedToArray","token","fallback","maxDepth","getVariableValue","element","depth","arguments","length","undefined","concat","_parseCSSVariable","_parseCSSVariable2","resolved","window","getComputedStyle","getPropertyValue","trimmed","trim","parseFloat","resolveCSSVariables","visualElement","_ref","transitionEnd","target","Object","assign","_objectDestructuringEmpty","Element","_objectSpread","values","forEach","value","get","set","key"],"sources":["/Users/eyliu/Desktop/FitBuddy/node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs"],"sourcesContent":["import { invariant } from '../../../utils/errors.mjs';\nimport { isNumericalString } from '../../../utils/is-numerical-string.mjs';\nimport { isCSSVariableToken } from './is-css-variable.mjs';\n\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\nconst splitCSSVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n    const match = splitCSSVariableRegex.exec(current);\n    if (!match)\n        return [,];\n    const [, token, fallback] = match;\n    return [token, fallback];\n}\nconst maxDepth = 4;\nfunction getVariableValue(current, element, depth = 1) {\n    invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\n    const [token, fallback] = parseCSSVariable(current);\n    // No CSS variable detected\n    if (!token)\n        return;\n    // Attempt to read this CSS variable off the element\n    const resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        const trimmed = resolved.trim();\n        return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;\n    }\n    else if (isCSSVariableToken(fallback)) {\n        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n        return getVariableValue(fallback, element, depth + 1);\n    }\n    else {\n        return fallback;\n    }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\nfunction resolveCSSVariables(visualElement, { ...target }, transitionEnd) {\n    const element = visualElement.current;\n    if (!(element instanceof Element))\n        return { target, transitionEnd };\n    // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n    // only if they change but I think this reads clearer and this isn't a performance-critical path.\n    if (transitionEnd) {\n        transitionEnd = { ...transitionEnd };\n    }\n    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n    visualElement.values.forEach((value) => {\n        const current = value.get();\n        if (!isCSSVariableToken(current))\n            return;\n        const resolved = getVariableValue(current, element);\n        if (resolved)\n            value.set(resolved);\n    });\n    // Cycle through every target property and resolve CSS variables. Currently\n    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n    for (const key in target) {\n        const current = target[key];\n        if (!isCSSVariableToken(current))\n            continue;\n        const resolved = getVariableValue(current, element);\n        if (!resolved)\n            continue;\n        // Clone target if it hasn't already been\n        target[key] = resolved;\n        if (!transitionEnd)\n            transitionEnd = {};\n        // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n        // CSS variable. This will ensure that after the animation the component will reflect\n        // changes in the value of the CSS variable.\n        if (transitionEnd[key] === undefined) {\n            transitionEnd[key] = current;\n        }\n    }\n    return { target, transitionEnd };\n}\n\nexport { parseCSSVariable, resolveCSSVariables };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}