{"ast":null,"code":"'use client';\n\n// src/index.ts\nimport { getActiveElement, getAllFocusable, isTabbable } from \"@chakra-ui/dom-utils\";\nimport { useEventListener } from \"@chakra-ui/react-use-event-listener\";\nimport { useSafeLayoutEffect } from \"@chakra-ui/react-use-safe-layout-effect\";\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\";\nimport { useCallback, useRef } from \"react\";\nfunction preventReturnFocus(containerRef) {\n  var el = containerRef.current;\n  if (!el) return false;\n  var activeElement = getActiveElement(el);\n  if (!activeElement) return false;\n  if (el.contains(activeElement)) return false;\n  if (isTabbable(activeElement)) return true;\n  return false;\n}\nfunction useFocusOnHide(containerRef, options) {\n  var shouldFocusProp = options.shouldFocus,\n    visible = options.visible,\n    focusRef = options.focusRef;\n  var shouldFocus = shouldFocusProp && !visible;\n  useUpdateEffect(function () {\n    if (!shouldFocus) return;\n    if (preventReturnFocus(containerRef)) {\n      return;\n    }\n    var el = (focusRef == null ? void 0 : focusRef.current) || containerRef.current;\n    var rafId;\n    if (el) {\n      rafId = requestAnimationFrame(function () {\n        el.focus({\n          preventScroll: true\n        });\n      });\n      return function () {\n        cancelAnimationFrame(rafId);\n      };\n    }\n  }, [shouldFocus, containerRef, focusRef]);\n}\nvar defaultOptions = {\n  preventScroll: true,\n  shouldFocus: false\n};\nfunction useFocusOnShow(target) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;\n  var focusRef = options.focusRef,\n    preventScroll = options.preventScroll,\n    shouldFocus = options.shouldFocus,\n    visible = options.visible;\n  var element = isRefObject(target) ? target.current : target;\n  var autoFocusValue = shouldFocus && visible;\n  var autoFocusRef = useRef(autoFocusValue);\n  var lastVisibleRef = useRef(visible);\n  useSafeLayoutEffect(function () {\n    if (!lastVisibleRef.current && visible) {\n      autoFocusRef.current = autoFocusValue;\n    }\n    lastVisibleRef.current = visible;\n  }, [visible, autoFocusValue]);\n  var onFocus = useCallback(function () {\n    if (!visible || !element || !autoFocusRef.current) return;\n    autoFocusRef.current = false;\n    if (element.contains(document.activeElement)) return;\n    if (focusRef == null ? void 0 : focusRef.current) {\n      requestAnimationFrame(function () {\n        var _a;\n        (_a = focusRef.current) == null ? void 0 : _a.focus({\n          preventScroll: preventScroll\n        });\n      });\n    } else {\n      var tabbableEls = getAllFocusable(element);\n      if (tabbableEls.length > 0) {\n        requestAnimationFrame(function () {\n          tabbableEls[0].focus({\n            preventScroll: preventScroll\n          });\n        });\n      }\n    }\n  }, [visible, preventScroll, element, focusRef]);\n  useUpdateEffect(function () {\n    onFocus();\n  }, [onFocus]);\n  useEventListener(element, \"transitionend\", onFocus);\n}\nfunction isRefObject(val) {\n  return \"current\" in val;\n}\nexport { useFocusOnHide, useFocusOnShow };","map":{"version":3,"names":["getActiveElement","getAllFocusable","isTabbable","useEventListener","useSafeLayoutEffect","useUpdateEffect","useCallback","useRef","preventReturnFocus","containerRef","el","current","activeElement","contains","useFocusOnHide","options","shouldFocusProp","shouldFocus","visible","focusRef","rafId","requestAnimationFrame","focus","preventScroll","cancelAnimationFrame","defaultOptions","useFocusOnShow","target","arguments","length","undefined","element","isRefObject","autoFocusValue","autoFocusRef","lastVisibleRef","onFocus","document","_a","tabbableEls","val"],"sources":["/Users/eyliu/Desktop/FitBuddy/node_modules/@chakra-ui/react-use-focus-effect/src/index.ts"],"sourcesContent":["import {\n  FocusableElement,\n  getActiveElement,\n  getAllFocusable,\n  isTabbable,\n} from \"@chakra-ui/dom-utils\"\nimport { useEventListener } from \"@chakra-ui/react-use-event-listener\"\nimport { useSafeLayoutEffect } from \"@chakra-ui/react-use-safe-layout-effect\"\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\"\nimport type { RefObject } from \"react\"\nimport { useCallback, useRef } from \"react\"\n\nexport interface UseFocusOnHideOptions {\n  focusRef: RefObject<FocusableElement>\n  shouldFocus?: boolean\n  visible?: boolean\n}\n\nfunction preventReturnFocus(containerRef: React.RefObject<HTMLElement>) {\n  const el = containerRef.current\n  if (!el) return false\n\n  const activeElement = getActiveElement(el)\n\n  if (!activeElement) return false\n  if (el.contains(activeElement)) return false\n  if (isTabbable(activeElement)) return true\n\n  return false\n}\n\n/**\n * Popover hook to manage the focus when the popover closes or hides.\n *\n * We either want to return focus back to the popover trigger or\n * let focus proceed normally if user moved to another interactive\n * element in the viewport.\n */\nexport function useFocusOnHide(\n  containerRef: RefObject<HTMLElement>,\n  options: UseFocusOnHideOptions,\n) {\n  const { shouldFocus: shouldFocusProp, visible, focusRef } = options\n\n  const shouldFocus = shouldFocusProp && !visible\n\n  useUpdateEffect(() => {\n    if (!shouldFocus) return\n\n    if (preventReturnFocus(containerRef)) {\n      return\n    }\n\n    const el = focusRef?.current || containerRef.current\n\n    let rafId: number\n\n    if (el) {\n      rafId = requestAnimationFrame(() => {\n        el.focus({ preventScroll: true })\n      })\n      return () => {\n        cancelAnimationFrame(rafId)\n      }\n    }\n  }, [shouldFocus, containerRef, focusRef])\n}\n\nexport interface UseFocusOnShowOptions {\n  visible?: boolean\n  shouldFocus?: boolean\n  preventScroll?: boolean\n  focusRef?: React.RefObject<FocusableElement>\n}\n\nconst defaultOptions: UseFocusOnShowOptions = {\n  preventScroll: true,\n  shouldFocus: false,\n}\n\nexport function useFocusOnShow<T extends HTMLElement>(\n  target: React.RefObject<T> | T,\n  options = defaultOptions,\n) {\n  const { focusRef, preventScroll, shouldFocus, visible } = options\n  const element = isRefObject(target) ? target.current : target\n\n  const autoFocusValue = shouldFocus && visible\n  const autoFocusRef = useRef(autoFocusValue)\n  const lastVisibleRef = useRef(visible)\n\n  useSafeLayoutEffect(() => {\n    if (!lastVisibleRef.current && visible) {\n      autoFocusRef.current = autoFocusValue\n    }\n    lastVisibleRef.current = visible\n  }, [visible, autoFocusValue])\n\n  const onFocus = useCallback(() => {\n    if (!visible || !element || !autoFocusRef.current) return\n    autoFocusRef.current = false\n\n    if (element.contains(document.activeElement as HTMLElement)) return\n\n    if (focusRef?.current) {\n      requestAnimationFrame(() => {\n        focusRef.current?.focus({ preventScroll })\n      })\n    } else {\n      const tabbableEls = getAllFocusable(element)\n      if (tabbableEls.length > 0) {\n        requestAnimationFrame(() => {\n          tabbableEls[0].focus({ preventScroll })\n        })\n      }\n    }\n  }, [visible, preventScroll, element, focusRef])\n\n  useUpdateEffect(() => {\n    onFocus()\n  }, [onFocus])\n\n  useEventListener(element, \"transitionend\", onFocus)\n}\n\nfunction isRefObject(val: any): val is { current: any } {\n  return \"current\" in val\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}