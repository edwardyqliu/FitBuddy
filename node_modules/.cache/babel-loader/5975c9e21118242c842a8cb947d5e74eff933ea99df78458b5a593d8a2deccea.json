{"ast":null,"code":"'use client';\n\nimport _objectSpread from \"/Users/eyliu/Desktop/FitBuddy/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/eyliu/Desktop/FitBuddy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/eyliu/Desktop/FitBuddy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// src/pan-event.ts\nimport { addPointerEvent, getEventPoint, isMultiTouchEvent } from \"@chakra-ui/event-utils\";\nimport sync, { cancelSync, getFrameData } from \"framesync\";\nvar PanEvent = /*#__PURE__*/function () {\n  function PanEvent(event, handlers, threshold) {\n    var _this = this;\n    _classCallCheck(this, PanEvent);\n    /**\n     * We use this to keep track of the `x` and `y` pan session history\n     * as the pan event happens. It helps to calculate the `offset` and `delta`\n     */\n    __publicField(this, \"history\", []);\n    // The pointer event that started the pan session\n    __publicField(this, \"startEvent\", null);\n    // The current pointer event for the pan session\n    __publicField(this, \"lastEvent\", null);\n    // The current pointer event info for the pan session\n    __publicField(this, \"lastEventInfo\", null);\n    __publicField(this, \"handlers\", {});\n    __publicField(this, \"removeListeners\", function () {});\n    /**\n     * Minimal pan distance required before recognizing the pan.\n     * @default \"3px\"\n     */\n    __publicField(this, \"threshold\", 3);\n    __publicField(this, \"win\");\n    __publicField(this, \"updatePoint\", function () {\n      if (!(_this.lastEvent && _this.lastEventInfo)) return;\n      var info = getPanInfo(_this.lastEventInfo, _this.history);\n      var isPanStarted = _this.startEvent !== null;\n      var isDistancePastThreshold = distance(info.offset, {\n        x: 0,\n        y: 0\n      }) >= _this.threshold;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      var _getFrameData = getFrameData(),\n        timestamp = _getFrameData.timestamp;\n      _this.history.push(_objectSpread(_objectSpread({}, info.point), {}, {\n        timestamp: timestamp\n      }));\n      var _this$handlers = _this.handlers,\n        onStart = _this$handlers.onStart,\n        onMove = _this$handlers.onMove;\n      if (!isPanStarted) {\n        onStart == null ? void 0 : onStart(_this.lastEvent, info);\n        _this.startEvent = _this.lastEvent;\n      }\n      onMove == null ? void 0 : onMove(_this.lastEvent, info);\n    });\n    __publicField(this, \"onPointerMove\", function (event, info) {\n      _this.lastEvent = event;\n      _this.lastEventInfo = info;\n      sync.update(_this.updatePoint, true);\n    });\n    __publicField(this, \"onPointerUp\", function (event, info) {\n      var panInfo = getPanInfo(info, _this.history);\n      var _this$handlers2 = _this.handlers,\n        onEnd = _this$handlers2.onEnd,\n        onSessionEnd = _this$handlers2.onSessionEnd;\n      onSessionEnd == null ? void 0 : onSessionEnd(event, panInfo);\n      _this.end();\n      if (!onEnd || !_this.startEvent) return;\n      onEnd == null ? void 0 : onEnd(event, panInfo);\n    });\n    var _a;\n    this.win = (_a = event.view) != null ? _a : window;\n    if (isMultiTouchEvent(event)) return;\n    this.handlers = handlers;\n    if (threshold) {\n      this.threshold = threshold;\n    }\n    event.stopPropagation();\n    event.preventDefault();\n    var info = {\n      point: getEventPoint(event)\n    };\n    var _getFrameData2 = getFrameData(),\n      timestamp = _getFrameData2.timestamp;\n    this.history = [_objectSpread(_objectSpread({}, info.point), {}, {\n      timestamp: timestamp\n    })];\n    var onSessionStart = handlers.onSessionStart;\n    onSessionStart == null ? void 0 : onSessionStart(event, getPanInfo(info, this.history));\n    this.removeListeners = pipe(addPointerEvent(this.win, \"pointermove\", this.onPointerMove), addPointerEvent(this.win, \"pointerup\", this.onPointerUp), addPointerEvent(this.win, \"pointercancel\", this.onPointerUp));\n  }\n  _createClass(PanEvent, [{\n    key: \"updateHandlers\",\n    value: function updateHandlers(handlers) {\n      this.handlers = handlers;\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      var _a;\n      (_a = this.removeListeners) == null ? void 0 : _a.call(this);\n      cancelSync.update(this.updatePoint);\n    }\n  }]);\n  return PanEvent;\n}();\nfunction subtract(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y\n  };\n}\nfunction getPanInfo(info, history) {\n  return {\n    point: info.point,\n    delta: subtract(info.point, history[history.length - 1]),\n    offset: subtract(info.point, history[0]),\n    velocity: getVelocity(history, 0.1)\n  };\n}\nvar toMilliseconds = function toMilliseconds(v) {\n  return v * 1e3;\n};\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  var i = history.length - 1;\n  var timestampedPoint = null;\n  var lastPoint = history[history.length - 1];\n  while (i >= 0) {\n    timestampedPoint = history[i];\n    if (lastPoint.timestamp - timestampedPoint.timestamp > toMilliseconds(timeDelta)) {\n      break;\n    }\n    i--;\n  }\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  var currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n  return currentVelocity;\n}\nfunction pipe() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n  return function (v) {\n    return fns.reduce(function (a, b) {\n      return b(a);\n    }, v);\n  };\n}\nfunction distance1D(a, b) {\n  return Math.abs(a - b);\n}\nfunction isPoint(point) {\n  return \"x\" in point && \"y\" in point;\n}\nfunction distance(a, b) {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return distance1D(a, b);\n  }\n  if (isPoint(a) && isPoint(b)) {\n    var xDelta = distance1D(a.x, b.x);\n    var yDelta = distance1D(a.y, b.y);\n    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2));\n  }\n  return 0;\n}\nexport { PanEvent, distance };","map":{"version":3,"names":["addPointerEvent","getEventPoint","isMultiTouchEvent","sync","cancelSync","getFrameData","PanEvent","event","handlers","threshold","_this","_classCallCheck","__publicField","lastEvent","lastEventInfo","info","getPanInfo","history","isPanStarted","startEvent","isDistancePastThreshold","distance","offset","x","y","_getFrameData","timestamp","push","_objectSpread","point","_this$handlers","onStart","onMove","update","updatePoint","panInfo","_this$handlers2","onEnd","onSessionEnd","end","_a","win","view","window","stopPropagation","preventDefault","_getFrameData2","onSessionStart","removeListeners","pipe","onPointerMove","onPointerUp","_createClass","key","value","updateHandlers","call","subtract","a","b","delta","length","velocity","getVelocity","toMilliseconds","v","timeDelta","i","timestampedPoint","lastPoint","time","currentVelocity","Infinity","_len","arguments","fns","Array","_key","reduce","distance1D","Math","abs","isPoint","xDelta","yDelta","sqrt","pow"],"sources":["/Users/eyliu/Desktop/FitBuddy/node_modules/@chakra-ui/react-use-pan-event/src/pan-event.ts"],"sourcesContent":["import {\n  addPointerEvent,\n  getEventPoint,\n  isMultiTouchEvent,\n} from \"@chakra-ui/event-utils\"\nimport sync, { cancelSync, getFrameData } from \"framesync\"\nimport {\n  AnyPointerEvent,\n  PanEventHandlers,\n  PanEventHistory,\n  Point,\n  PointerEventInfo,\n  TimestampedPoint,\n} from \"./types\"\n\n/**\n * A Pan Session is recognized when the pointer is down\n * and moved in the allowed direction.\n */\nexport class PanEvent {\n  /**\n   * We use this to keep track of the `x` and `y` pan session history\n   * as the pan event happens. It helps to calculate the `offset` and `delta`\n   */\n  private history: PanEventHistory = []\n\n  // The pointer event that started the pan session\n  private startEvent: AnyPointerEvent | null = null\n\n  // The current pointer event for the pan session\n  private lastEvent: AnyPointerEvent | null = null\n\n  // The current pointer event info for the pan session\n  private lastEventInfo: PointerEventInfo | null = null\n\n  private handlers: Partial<PanEventHandlers> = {}\n\n  private removeListeners: Function = () => {}\n\n  /**\n   * Minimal pan distance required before recognizing the pan.\n   * @default \"3px\"\n   */\n  private threshold = 3\n\n  private win: typeof globalThis\n\n  constructor(\n    event: AnyPointerEvent,\n    handlers: Partial<PanEventHandlers>,\n    threshold?: number,\n  ) {\n    this.win = (event.view ?? window) as typeof globalThis.window\n\n    // If we have more than one touch, don't start detecting this gesture\n    if (isMultiTouchEvent(event)) return\n\n    this.handlers = handlers\n\n    if (threshold) {\n      this.threshold = threshold\n    }\n\n    // stop default browser behavior\n    event.stopPropagation()\n    event.preventDefault()\n\n    // get and save the `pointerdown` event info in history\n    // we'll use it to compute the `offset`\n    const info = { point: getEventPoint(event) }\n    const { timestamp } = getFrameData()\n    this.history = [{ ...info.point, timestamp }]\n\n    // notify pan session start\n    const { onSessionStart } = handlers\n    onSessionStart?.(event, getPanInfo(info, this.history))\n\n    // attach event listeners and return a single function to remove them all\n    this.removeListeners = pipe(\n      addPointerEvent(this.win, \"pointermove\", this.onPointerMove),\n      addPointerEvent(this.win, \"pointerup\", this.onPointerUp),\n      addPointerEvent(this.win, \"pointercancel\", this.onPointerUp),\n    )\n  }\n\n  private updatePoint = () => {\n    if (!(this.lastEvent && this.lastEventInfo)) return\n\n    const info = getPanInfo(this.lastEventInfo, this.history)\n\n    const isPanStarted = this.startEvent !== null\n\n    const isDistancePastThreshold =\n      distance(info.offset, { x: 0, y: 0 }) >= this.threshold\n\n    if (!isPanStarted && !isDistancePastThreshold) return\n\n    const { timestamp } = getFrameData()\n    this.history.push({ ...info.point, timestamp })\n\n    const { onStart, onMove } = this.handlers\n\n    if (!isPanStarted) {\n      onStart?.(this.lastEvent, info)\n      this.startEvent = this.lastEvent\n    }\n\n    onMove?.(this.lastEvent, info)\n  }\n\n  private onPointerMove = (event: AnyPointerEvent, info: PointerEventInfo) => {\n    this.lastEvent = event\n    this.lastEventInfo = info\n\n    // Throttle mouse move event to once per frame\n    sync.update(this.updatePoint, true)\n  }\n\n  private onPointerUp = (event: AnyPointerEvent, info: PointerEventInfo) => {\n    // notify pan session ended\n    const panInfo = getPanInfo(info, this.history)\n    const { onEnd, onSessionEnd } = this.handlers\n\n    onSessionEnd?.(event, panInfo)\n    this.end()\n\n    // if panning never started, no need to call `onEnd`\n    // panning requires a pointermove of at least 3px\n    if (!onEnd || !this.startEvent) return\n\n    onEnd?.(event, panInfo)\n  }\n\n  updateHandlers(handlers: Partial<PanEventHandlers>) {\n    this.handlers = handlers\n  }\n\n  end() {\n    this.removeListeners?.()\n    cancelSync.update(this.updatePoint)\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Utilities\n * -----------------------------------------------------------------------------*/\n\nfunction subtract(a: Point, b: Point) {\n  return { x: a.x - b.x, y: a.y - b.y }\n}\n\nfunction getPanInfo(info: PointerEventInfo, history: PanEventHistory) {\n  return {\n    point: info.point,\n    delta: subtract(info.point, history[history.length - 1]),\n    offset: subtract(info.point, history[0]),\n    velocity: getVelocity(history, 0.1),\n  }\n}\n\nconst toMilliseconds = (v: number) => v * 1000\n\nfunction getVelocity(history: TimestampedPoint[], timeDelta: number): Point {\n  if (history.length < 2) {\n    return { x: 0, y: 0 }\n  }\n\n  let i = history.length - 1\n  let timestampedPoint: TimestampedPoint | null = null\n  const lastPoint = history[history.length - 1]\n  while (i >= 0) {\n    timestampedPoint = history[i]\n    if (\n      lastPoint.timestamp - timestampedPoint.timestamp >\n      toMilliseconds(timeDelta)\n    ) {\n      break\n    }\n    i--\n  }\n\n  if (!timestampedPoint) {\n    return { x: 0, y: 0 }\n  }\n\n  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000\n  if (time === 0) {\n    return { x: 0, y: 0 }\n  }\n\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time,\n  }\n\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0\n  }\n\n  return currentVelocity\n}\n\nfunction pipe<R>(...fns: Array<(a: R) => R>) {\n  return (v: R) => fns.reduce((a, b) => b(a), v)\n}\n\nfunction distance1D(a: number, b: number) {\n  return Math.abs(a - b)\n}\n\nfunction isPoint(point: any): point is { x: number; y: number } {\n  return \"x\" in point && \"y\" in point\n}\n\nexport function distance<P extends Point | number>(a: P, b: P) {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return distance1D(a, b)\n  }\n\n  if (isPoint(a) && isPoint(b)) {\n    const xDelta = distance1D(a.x, b.x)\n    const yDelta = distance1D(a.y, b.y)\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2)\n  }\n\n  return 0\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}